CS241 L21 | March 28^th^, 2019

# Optimizing Code Generation

The goal here is to reduce the amount of code generated by the compiler

## Constant Folding

For `1+2`, the current code would be

```ruby
lis $3
.word 1
sw $3, -4($30)
sub $30, $30, $4
lis $3
.word 2
add $30, $30, $4
lw $5, -4($30)
add $3, $3, $5
```

The compiler recognizes adding constants, so do the calculations at compile time, instead of at runtime. The code would then be shortened to

```ruby
lis $3
.word 3
```

## Constant Propagation

Consider the code

```c++
int x = 2;
...
return x + x;
```

What does our compiler actually generate? At the moment, we have

```ruby
lis $3
.word 2
sw $3, -4($30)
sub $30, $30, $4
lw $3, ___($29) # looking up offset for x
push($3)
lw $3, ___($29)
pop($5)
add $3, $3, $5
```

Instead, we could recognize that `x=2`, so we could optimize the generated code

```ruby
lis $3
.word 2
sw $3, -4($30)
sub $30, $30, $4
lis $3
.word 4
```

We still have to handle the declaration and initialization of the variable $x$, but we can precompute the value that `x+x` is equal to `2+2=4`. To take this further, if $x$ isn’t used anywhere else, we could just

```ruby
lis $3
.word 4
```

Even if $x$’s value is unknown, we could recognize that it’s value is in `$3`

```ruby
lw $3, ___($29)
add $3, $3, $3
```

## Common Subexpression Elimination

If we have something like `(a+b) * (a+b)`, instead of computing it twice, recognize that it’s being used twice and just use the initial calculated value. Use a register to hold `a+b` then multiply by itself!

## Dead Code Elimination

If you’re certain that some branch of your program will never run, do not generate code for it! Consider the code

```c++
int x = 2;
int y = 3;
if (x == y) {
    // statements 1
} else {
    // statements 2
}
```

We know that `statements 1` will never run, so don’t generate code for it! The code above is equivalent to 

```c++
int x = 2;
int y = 3;
// statements 2
```

## Register Allocation

It’s cheaper to use registers for variables instead of saving them on the stack. Though there are less options, it saves many `lw`, `sw`, and stack pointer updates. In most of our code, we don’t ever touch registers `$14` to `$28`. We could thus use these to hold the variables most commonly used, and the rest can go on the stack. 

==Note==: what if someone is asking for the memory address of a variable that you’ve put on registers? Something like arrays, if you take the address of a variable, it should have a RAM address. So store things in memory regardless. 

## Side Effects

We have to be careful when trying to optimize around the return values of procedures. The value it returns does not necessarily have to be constant.

```c++
int x = 2;
return x++ + x;
```

## Strength Reduction

`add` usually runs faster than `mult` in terms of hardware. So, instead of 

```ruby
lis $2
.word
mult $3, $2
mflo $3
```

we could just

```ruby
add $3, $3, $3
```

In the real world, here we would just shift the value by 1, effectively multiplying it by 2.

## Procedure-Specific

### Inlining

Suppose we have something like this

```c++
int f(int x) {
    return x + x;
}
int wain(int a, int b) {
    return f(a);
}
```

Instead of generating the code for `f()`, we could copy the body of the function into where the function occurs!

```c++
int wain(int a, int b) {
    return a + a;
}
```

This will save us the overhead of having to generate code for the specific function call (save \$31, load the label, save \$29, then restoring after we jump back). 

*When is this worthwhile to do?* There are a few things we need to consider.

- What’s bigger, the body of `f` or the code required to call `f`	
  - if these two are exactly equal, we should still inline! Since this means that $\downarrow$  
- If all calls to `f` are in-lined, we don’t need to generate code for proc `f` at all

## Tail Recursion

Recall that this means that there’s no work for the function to do once you’ve gotten the value back from the recursive call. This will look something like `return f(n-1)`, *not* `return n + f(n-1)`.

We’ll reuse the stack frame! So we use `jr` instead of `jalr` - don’t update registers `$29` or `$31`. If it’s recursive, we have the same arguments and local variables, so we don’t need to reallocate space on the stack. Just update the values directly!

# Memory Management (Heap)

If you want the data to outline its scope, copy the value to another scope. So we don’t duplicate the data, and the data could be big (only copy memory address instead). We could also just store the data on the heap.

> **Ex**: Suppose we have a list of free blocks. We need to maintain a linked list of pointers to free areas of the heap. 
>
> Initially, the entire heap is free, so our linked list $L$ has 1 entry. Supposed the heap is 1k.
>
> ```
> free
> | 1024 | / |              | # width of 1024
> ```
>
> We then request 16 bytes. We’ll have to actually allocate 20 bytes (16 bytes + 1 int (4 bytes)), and then return the pointer to the 2nd word. We are storing the *size* right before the pointer. The free list $L$ then contains the rest of the heap.
>
> ```
> block
> | 20 | (16 bytes) |
> free
> | 1004 | / |              |
> ```
>
> Then we request 28 bytes (which is actually 32 bytes)
>
> ```
> block
> | 32 | (28 bytes) |
> free
> | 972 | / |               |
> ```
>
> Suppose the first block (20 bytes) is `free`’d, so `free(p); delete[] p` is called. `free` checks `p[-1]` to determine size of block to return, then adds it to the free list. So our free list would then be
>
> ```
> | 20 | . |              |
> . points to
> | 974 | / |             |
> ```
>
> If we free the other block as well (32 bytes), then we have
>
> ```
> | 20 | . |              |
> . points to
> | 32 | . |              |
> . points to
> | 974 | / |             |
> ```
>
> But our data structure should recognize that these blocks are contiguous, so we group them together and get
>
> ```
> | 1024 | / |            |
> ```
>
> as our free list. 

What if we have repeated `new` and `deletes`? This may cause “holes” in our heap, called ==memory fragmentation==.

>```
>alloc 20		|....|                              |
>alloc 40		|....|........|                     |
>free 20			|    |........|                     |
>alloc 5			|.|  |........|                     |
>alloc 20		|.|  |........|....|                |
>```
>
>We have 15 bytes of unused space. 

So it can happen that even if $n$ bytes are free, we may not be able to allocate a block of $n$ bytes. How can we reduce fragmentation?

Don’t always use the first block of RAM that is big enough to satisfy the request. There are options we can take to find the block to use:

1. First Fit: choose first block that satisfied request
2. Best Fit: find block with minimum leftover space. This requires us to search available RAM to choose a block, which takes time. *There is a cost to memory management*.

